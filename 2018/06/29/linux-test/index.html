<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Linux网络编程–epoll 模型原理详解以及实例###1.简介Linux I/O多路复用技术在比较多的TCP网络服务器中有使用，即比较多的用到select函数。Linux 2.6内核中有提高网络I/O性能的新方法，即epoll 。epoll是什么？按照man手册的说法是为处理大批量句柄而作了改进的poll。要使用epoll只需要以下的三个系统函数调用： epoll_create，epoll_c">
<meta property="og:type" content="article">
<meta property="og:title" content="jincheng">
<meta property="og:url" content="http://yoursite.com/2018/06/29/linux-test/index.html">
<meta property="og:site_name" content="jincheng">
<meta property="og:description" content="Linux网络编程–epoll 模型原理详解以及实例###1.简介Linux I/O多路复用技术在比较多的TCP网络服务器中有使用，即比较多的用到select函数。Linux 2.6内核中有提高网络I/O性能的新方法，即epoll 。epoll是什么？按照man手册的说法是为处理大批量句柄而作了改进的poll。要使用epoll只需要以下的三个系统函数调用： epoll_create，epoll_c">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-06-29T05:08:25.674Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jincheng">
<meta name="twitter:description" content="Linux网络编程–epoll 模型原理详解以及实例###1.简介Linux I/O多路复用技术在比较多的TCP网络服务器中有使用，即比较多的用到select函数。Linux 2.6内核中有提高网络I/O性能的新方法，即epoll 。epoll是什么？按照man手册的说法是为处理大批量句柄而作了改进的poll。要使用epoll只需要以下的三个系统函数调用： epoll_create，epoll_c">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/29/linux-test/"/>





  <title> | jincheng</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/goodfay" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">jincheng</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/29/linux-test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jincheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jincheng">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-29T13:05:22+08:00">
                2018-06-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Linux网络编程–epoll-模型原理详解以及实例"><a href="#Linux网络编程–epoll-模型原理详解以及实例" class="headerlink" title="Linux网络编程–epoll 模型原理详解以及实例"></a>Linux网络编程–epoll 模型原理详解以及实例</h2><p>###1.简介<br>Linux I/O多路复用技术在比较多的TCP网络服务器中有使用，即比较多的用到<code>select</code>函数。Linux 2.6内核中有提高网络I/O性能的新方法，即epoll 。<br><code>epoll</code>是什么？按照man手册的说法是为处理大批量句柄而作了改进的poll。要使用epoll只需要以下的三个系统函数调用： <code>epoll_create</code>，<code>epoll_ctl</code>，<code>epoll_wait</code>。</p>
<p>###2.select模型的缺陷</p>
<p>####(1) 在Linux内核中，select所用到的FD_SET是有限的<br>内核中有个参数<strong><code>FD_SETSIZE</code>定义了每个<code>FD_SET</code>的句柄个数：`#define </strong>FD_SETSIZE 1024`。也就是说，如果想要同时检测1025个句柄的可读状态是不可能用select实现的；或者同时检测1025个句柄的可写状态也是不可能的。 </p>
<p>####(2) 内核中实现select是使用轮询方法<br>每次检测都会遍历所有<code>FD_SET</code>中的句柄，显然select函数的执行时间与<code>FD_SET</code>中句柄的个数有一个比例关系，即select要检测的句柄数越多就会越费时</p>
<p>###3.Windows IOCP模型的缺陷<br>windows完成端口实现的AIO，实际上也只是使用内部用线程池实现的，最后的结果是IO有个线程池，你的应用程序也需要一个线程池。很多文档其实已经指出了这引发的线程context-switch所带来的代价。</p>
<p>###4.EPOLL模型的优点<br>(1) 支持一个进程打开大数目的socket描述符(FD)<br>epoll没有select模型中的限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于select 所支持的2048。下面是我的小PC机上的显示：<br><figure class="highlight plain"><figcaption><span>cat</span><a href="/proc/sys/fs/file-max">```</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">6815744 </span><br><span class="line">那么对于服务器而言,这个数目会更大。 </span><br><span class="line">(2) IO效率不随FD数目增加而线性下降 </span><br><span class="line">传统select/poll的另一个致命弱点就是当你拥有一个很大的socket集合，由于网络得延时，使得任一时间只有部分的socket是”活跃”的，而select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它只会对”活跃”的socket进行操作：这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。于是，只有”活跃”的socket才会主动去调用callback函数，其他idle状态的socket则不会。在这点上，epoll实现了一个”伪”AIO”，因为这时候推动力在os内核。在一些 benchmark中，如果所有的socket基本上都是活跃的，比如一个高速LAN环境，epoll也不比select/poll低多少效率，但若过多使用的调用epoll_ctl，效率稍微有些下降。然而一旦使用idle connections模拟WAN环境，那么epoll的效率就远在select/poll之上了。 </span><br><span class="line">(3) 使用mmap加速内核与用户空间的消息传递 </span><br><span class="line">无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就显得很重要。在这点上，epoll是通过内核于用户空间mmap同一块内存实现。</span><br><span class="line"></span><br><span class="line">###5.EPOLL模型的工作模式</span><br><span class="line">####(1) LT模式 </span><br><span class="line">`LT：level triggered`，这是缺省的工作方式，同时支持`block`和`no-block socket`，在这种模式中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。 </span><br><span class="line">####(2) ET模式 </span><br><span class="line">`ET：edge-triggered`，这是高速工作方式，只支持`no-block socket`。在这种模式下，当描述符从未就绪变为就绪时，内核就通过epoll告诉你，然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作而导致那个文件描述符不再是就绪状态(比如你在发送，接收或是接受请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误)。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核就不会发送更多的通知(only once)。不过在TCP协议中，ET模式的加速效用仍需要更多的benchmark确认。</span><br><span class="line"></span><br><span class="line">###6.EPOLL模型的使用方法</span><br><span class="line">epoll用到的所有函数都是在头文件`sys/epoll.h`中声明的，下面简要说明所用到的数据结构和函数：</span><br></pre></td></tr></table></figure></p>
<p>epoll_data、epoll_data_t、epoll_event<br>typedef union epoll_data {<br>void *ptr;<br>int fd;<br><strong>uint32_t u32; 
</strong>uint64_t u64;<br>} epoll_data_t;</p>
<p>struct epoll_event {<br>__uint32_t events; /<em> Epoll events </em>/<br>epoll_data_t data; /<em> User data variable </em>/<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">结构体epoll_event 被用于注册所感兴趣的事件和回传所发生待处理的事件。epoll_event 结构体的events字段是表示感兴趣的事件和被触发的事件，可能的取值为： </span><br><span class="line">`EPOLLIN`： 表示对应的文件描述符可以读； </span><br><span class="line">`EPOLLOUT`： 表示对应的文件描述符可以写； </span><br><span class="line">`EPOLLPRI`： 表示对应的文件描述符有紧急的数据可读； </span><br><span class="line">`EPOLLERR`： 表示对应的文件描述符发生错误； </span><br><span class="line">`EPOLLHUP`： 表示对应的文件描述符被挂断； </span><br><span class="line">`EPOLLET`： 表示对应的文件描述符有事件发生；</span><br><span class="line"></span><br><span class="line">联合体epoll_data用来保存触发事件的某个文件描述符相关的数据。例如一个client连接到服务器，服务器通过调用accept函数可以得到于这个client对应的socket文件描述符，可以把这文件描述符赋给epoll_data的fd字段，以便后面的读写操作在这个文件描述符上进行。</span><br><span class="line"></span><br><span class="line">(2)`epoll_create `</span><br><span class="line">函数声明：`intepoll_create(intsize) `</span><br><span class="line">函数说明：该函数生成一个epoll专用的文件描述符，其中的参数是指定生成描述符的最大范围。</span><br><span class="line"></span><br><span class="line">(3) `epoll_ctl`函数 </span><br><span class="line">函数声明：`intepoll_ctl(int epfd,int op, int fd, struct epoll_event *event) `</span><br><span class="line">函数说明：该函数用于控制某个文件描述符上的事件，可以注册事件、修改事件、删除事件。 </span><br><span class="line">`epfd`：由 epoll_create 生成的epoll专用的文件描述符； </span><br><span class="line">`op`：要进行的操作，可能的取值EPOLL_CTL_ADD 注册、EPOLL_CTL_MOD 修改、EPOLL_CTL_DEL 删除； </span><br><span class="line">`fd`：关联的文件描述符； </span><br><span class="line">`event`：指向epoll_event的指针； </span><br><span class="line">如果调用成功则返回0，不成功则返回-1。</span><br><span class="line"></span><br><span class="line">(4) `epoll_wait`函数 </span><br><span class="line">函数声明：`int epoll_wait(int epfd, structepoll_event * events, int maxevents, int timeout) `</span><br><span class="line">函数说明：该函数用于轮询I/O事件的发生。 </span><br><span class="line">`epfd`：由epoll_create 生成的epoll专用的文件描述符； </span><br><span class="line">`epoll_event`：用于回传代处理事件的数组； </span><br><span class="line">`maxevents`：每次能处理的事件数； </span><br><span class="line">`timeout`：等待I/O事件发生的超时值； </span><br><span class="line">返回发生事件数。</span><br><span class="line"></span><br><span class="line">###7 设计思路及模板</span><br><span class="line">首先通过`create_epoll(int maxfds)`来创建一个epoll的句柄，其中maxfds为你的epoll所支持的最大句柄数。这个函数会返回一个新的epoll句柄，之后的所有操作都将通过这个句柄来进行操作。在用完之后，记得用close()来关闭这个创建出来的epoll句柄。 </span><br><span class="line">然后在你的网络主循环里面，调用`epoll_wait(int epfd, epoll_event events, int max_events,int timeout)`来查询所有的网络接口，看哪一个可以读，哪一个可以写。基本的语法为： </span><br><span class="line">`nfds = epoll_wait(kdpfd, events, maxevents, -1); `</span><br><span class="line">其中`kdpfd`为用`epoll_create`创建之后的句柄，events是一个`epoll_event*`的指针，当`epoll_wait`函数操作成功之后，events里面将储存所有的读写事件。max_events是当前需要监听的所有socket句柄数。最后一个timeout参数指示 epoll_wait的超时条件，为0时表示马上返回；为-1时表示函数会一直等下去直到有事件返回；为任意正整数时表示等这么长的时间，如果一直没有事件，则会返回。一般情况下如果网络主循环是单线程的话，可以用-1来等待，这样可以保证一些效率，如果是和主循环在同一个线程的话，则可以用0来保证主循环的效率。epoll_wait返回之后，应该进入一个循环，以便遍历所有的事件。 </span><br><span class="line">对epoll 的操作就这么简单，总共不过4个`API：epoll_create, epoll_ctl,epoll_wait和close`。以下是man中的一个例子。</span><br></pre></td></tr></table></figure></p>
<p>struct epoll_event ev, <em>events;<br>for(;;)<br>{<br>  nfds = epoll_wait(kdpfd, events, maxevents, -1);    //等待IO事件<br>  for(n = 0; n &lt; nfds; ++n)<br>  {<br>  //如果是主socket的事件，则表示有新连接进入，需要进行新连接的处理。<br>      if(events[n].data.fd == listener)<br>      {<br>        client = accept(listener, (struct sockaddr </em>) &amp;local,  &amp;addrlen);<br>if(client &lt; 0)<br>        {<br>            perror(“accept error”);<br>            continue;<br>        }<br>        // 将新连接置于非阻塞模式<br>        setnonblocking(client);<br>        ev.events = EPOLLIN | EPOLLET;<br>        //注意这里的参数EPOLLIN | EPOLLET并没有设置对写socket的监听，<br>        //如果有写操作的话，这个时候epoll是不会返回事件的，<br>        //如果要对写操作也监听的话，应该是EPOLLIN | EPOLLOUT | EPOLLET。<br>        // 并且将新连接也加入EPOLL的监听队列<br>        ev.data.fd = client;<br>        // 设置好event之后，将这个新的event通过epoll_ctl<br>        if (epoll_ctl(kdpfd, EPOLL_CTL_ADD, client, &amp;ev) &lt; 0)<br>        {<br>            //加入到epoll的监听队列里，这里用EPOLL_CTL_ADD<br>            //来加一个新的 epoll事件。可以通过EPOLL_CTL_DEL来减少<br>            //一个epoll事件，通过EPOLL_CTL_MOD来改变一个事件的监听方式。<br>            fprintf(stderr, “epoll set insertion error: fd=%d”0, client);<br>            return -1;<br>        }<br>      }<br>      else<br>      // 如果不是主socket的事件的话，则代表这是一个用户的socket的事件，<br>      // 则用来处理这个用户的socket的事情是，比如说read(fd,xxx)之类，或者一些其他的处理。<br>        do_use_fd(events[n].data.fd);<br>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###8 EPOLL模型的简单实例</span><br></pre></td></tr></table></figure></p>
<p>#include <iostream></iostream></p>
<p>#include &lt;sys/socket.h&gt; </p>
<p>#include &lt;sys/epoll.h&gt;</p>
<p>#include &lt;netinet/in.h&gt; </p>
<p>#include &lt;arpa/inet.h&gt;</p>
<p>#include &lt;fcntl.h&gt; </p>
<p>#include &lt;unistd.h&gt; </p>
<p>#include &lt;stdio.h&gt;</p>
<p>#define MAXLINE 10 </p>
<p>#define OPEN_MAX 100</p>
<p>#define LISTENQ 20</p>
<p>#define SERV_PORT 5555 </p>
<p>#define INFTIM 1000</p>
<p>void setnonblocking(int sock)<br>{<br>  int opts;<br>  opts = fcntl(sock, F_GETFL);<br>  if(opts &lt; 0)<br>  {<br>      perror(“fcntl(sock, GETFL)”);<br>      exit(1);<br>  }<br>  opts = opts | O_NONBLOCK;<br>  if(fcntl(sock, F_SETFL, opts) &lt; 0)<br>  {<br>      perror(“fcntl(sock,SETFL,opts)”);<br>      exit(1);<br>  }<br>}</p>
<p>int main()<br>{<br>  int i, maxi, listenfd, connfd, sockfd, epfd, nfds;<br>  ssize_t n;<br>  char line[MAXLINE];<br>  socklen_t clilen;<br>  //声明epoll_event结构体的变量, ev用于注册事件, events数组用于回传要处理的事件<br>  struct epoll_event ev,events[20];<br>  //生成用于处理accept的epoll专用的文件描述符, 指定生成描述符的最大范围为256<br>  epfd = epoll_create(256);<br>  struct sockaddr_in clientaddr;<br>  struct sockaddr_in serveraddr;<br>  listenfd = socket(AF_INET, SOCK_STREAM, 0);</p>
<p>  setnonblocking(listenfd);      //把用于监听的socket设置为非阻塞方式<br>  ev.data.fd = listenfd;          //设置与要处理的事件相关的文件描述符<br>  ev.events = EPOLLIN | EPOLLET;  //设置要处理的事件类型<br>  epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev);    //注册epoll事件<br>  bzero(&amp;serveraddr, sizeof(serveraddr));<br>  serveraddr.sin_family = AF_INET;<br>  char <em>local_addr = “200.200.200.204”;<br>  inet_aton(local_addr, &amp;(serveraddr.sin_addr));<br>  serveraddr.sin_port = htons(SERV_PORT);  //或者htons(SERV_PORT);<br>  bind(listenfd,(sockaddr </em>)&amp;serveraddr, sizeof(serveraddr));<br>  listen(listenfd, LISTENQ);</p>
<p>  maxi = 0;<br>  for( ; ; )<br>  {<br>      nfds = epoll_wait(epfd, events, 20, 500); //等待epoll事件的发生<br>      for(i = 0; i &lt; nfds; ++i)                //处理所发生的所有事件<br>      {<br>        if(events[i].data.fd == listenfd)      //监听事件<br>        {<br>            connfd = accept(listenfd, (sockaddr <em>)&amp;clientaddr, &amp;clilen);<br>            if(connfd &lt; 0)<br>            {<br>              perror(“connfd&lt;0”);<br>              exit(1);<br>            }<br>            setnonblocking(connfd);          //把客户端的socket设置为非阻塞方式<br>            char </em>str = inet_ntoa(clientaddr.sin_addr);<br>            std::cout &lt;&lt; “connect from “ &lt;&lt; str  &lt;&lt;std::endl;<br>            ev.data.fd=connfd;                //设置用于读操作的文件描述符<br>            ev.events=EPOLLIN | EPOLLET;      //设置用于注测的读操作事件<br>            epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;ev);<br>            //注册ev事件<br>        }<br>        else if(events[i].events&amp;EPOLLIN)      //读事件<br>        {<br>            if ( (sockfd = events[i].data.fd) &lt; 0)<br>            {<br>              continue;<br>            }<br>            if ( (n = read(sockfd, line, MAXLINE)) &lt; 0) // 这里和IOCP不同<br>            {<br>              if (errno == ECONNRESET)<br>              {<br>                  close(sockfd);<br>                  events[i].data.fd = -1;<br>              }<br>              else<br>              {<br>                  std::cout&lt;&lt;”readline error”&lt;&lt;std::endl;<br>              }<br>            }<br>            else if (n == 0)<br>            {<br>              close(sockfd);<br>              events[i].data.fd = -1;<br>            }<br>            ev.data.fd=sockfd;              //设置用于写操作的文件描述符<br>            ev.events=EPOLLOUT | EPOLLET;  //设置用于注测的写操作事件<br>            //修改sockfd上要处理的事件为EPOLLOUT<br>            epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd, &amp;ev);<br>        }<br>        else if(events[i].events&amp;EPOLLOUT)//写事件<br>        {<br>            sockfd = events[i].data.fd;<br>            write(sockfd, line, n);<br>            ev.data.fd = sockfd;              //设置用于读操作的文件描述符<br>            ev.events = EPOLLIN | EPOLLET;    //设置用于注册的读操作事件<br>            //修改sockfd上要处理的事件为EPOLIN<br>            epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd, &amp;ev);<br>        }<br>      }<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###9.epoll进阶思考</span><br><span class="line"></span><br><span class="line">最近学习`EPOLL`模型，介绍中说将`EPOLL`与`Windows IOCP`模型进行比较，说其的优势在于解决了`IOCP`模型大量线程上下文切换的开销，于是可以看出，`EPOLL`模型不需要多线程，即单线程中可以处理`EPOLL`逻辑。如果引入多线程反而会引起一些问题。但是`EPOLL`模型的服务器端到底可以不可以用多线程技术，如果可以，改怎么取舍，这成了困扰我的问题。上网查了一下，有这样几种声音： </span><br><span class="line">(1) “要么事件驱动(如epoll)，要么多线程，要么多进程，把这几个综合起来使用，感觉更加麻烦。”； </span><br><span class="line">(2) “单线程使用epoll，但是不能发挥多核；多线程不用epoll。”； </span><br><span class="line">#####(3) “主通信线程使用epoll所有需要监控的FD，有事件交给多线程去处理”； </span><br><span class="line">#####(4) “既然用了epoll, 那么线程就不应该看到fd, 而只看到的是一个一个的业务请求/响应； epoll将网络数据组装成业务数据后, 转交给业务线程进行处理。这就是常说的半同步半异步”。 </span><br><span class="line">我比较赞同上述(3)、(4)中的观点 </span><br><span class="line">`EPOLLOUT`只有在缓冲区已经满了，不可以发送了，过了一会儿缓冲区中有空间了，就会触发`EPOLLOUT`，而且只触发一次。如果你编写的程序的网络IO不大，一次写入的数据不多的时候，通常都是`epoll_wait`立刻就会触发` EPOLLOUT`；如果你不调用` epoll`，直接写 `socket`，那么情况就取决于这个`socket`的缓冲区是不是足够了。如果缓冲区足够，那么写就成功。如果缓冲区不足，那么取决你的socket是不是阻塞的，要么阻塞到写完成，要么出错返回。所以EPOLLOUT事件具有较大的随机性，ET模式一般只用于`EPOLLIN`, 很少用于`EPOLLOUT`。 </span><br><span class="line">9.2. 具体做法 </span><br><span class="line">(1) 主通信线程使用epoll所有需要监控的FD，负责监控`listenfd`和`connfd`，这里只监听`EPOLLIN`事件，不监听`EPOLLOUT`事件； </span><br><span class="line">(2) 一旦从Client收到了数据以后，将其构造成一个消息，放入消息队列中； </span><br><span class="line">(3) 若干工作线程竞争，从消息队列中取出消息并进行处理，然后把处理结果发送给客户端。发送客户端的操作由工作线程完成。直接进行`write`。`write`到`EAGAIN`或`EWOULDBLOCK`后，线程循环`continue`等待缓冲区队列 </span><br><span class="line">发送函数代码如下：</span><br></pre></td></tr></table></figure></p>
<p>bool send_data(int connfd, char *pbuffer, unsigned int &amp;len,int flag)<br>{<br>  if ((connfd &lt; 0) || (0  == pbuffer))<br>  {<br>      return false;<br>  }</p>
<p>  int result = 0;<br>  int remain_size = (int) len;<br>  int send_size = 0;<br>  const char *p = pbuffer;</p>
<p>  time_t start_time = time(NULL);<br>  int time_out = 3;</p>
<p>  do<br>  {<br>      if (time(NULL) &gt; start + time_out)<br>      {<br>        return false;<br>      }</p>
<pre><code>send_size = send(connfd, p, remain_size, flag);
if (nSentSize &lt; 0)
{
  if ((errno == EAGAIN) || (errno == EWOULDBLOCK) || (errno == EINTR))
  {
      continue;
  }
  else
  {
      len -= remain_size;
      return false;
  }
}

p += send_size;
remain_size -= send_size;
</code></pre><p>  }while(remain_size &gt; 0);</p>
<p>  return true;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">###10 epoll 实现服务器和客户端例子</span><br><span class="line">最后我们用C++实现一个简单的客户端回射，所用到的代码文件是</span><br><span class="line"></span><br><span class="line">`net.h`  ` server.cpp `  `client.cpp`服务器端：epoll实现的，干两件事分别为：1.等待客户端的链接，2.接收来自客户端的数据并且回射；</span><br><span class="line"></span><br><span class="line">客户端：select实现，干两件事为:1.等待键盘输入，2.发送数据到服务器端并且接收服务器端回射的数据；</span><br><span class="line"></span><br><span class="line">**/***********</span><br><span class="line">net.h</span><br><span class="line">***********/**</span><br></pre></td></tr></table></figure></p>
<p>#include &lt;stdio.h&gt;</p>
<p>#ifndef _NET_H</p>
<p>#define _NET_H</p>
<p>#include <iostream></iostream></p>
<p>#include <vector></vector></p>
<p>#include <algorithm></algorithm></p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;sys/epoll.h&gt;  //epoll ways file</p>
<p>#include &lt;sys/socket.h&gt;</p>
<p>#include &lt;fcntl.h&gt;    //block and noblock</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;error.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;arpa/inet.h&gt;</p>
<p>#include &lt;netinet/in.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;signal.h&gt;</p>
<p>using namespace std;</p>
<p>#define hand_error(msg) do{perror(msg); exit(EXIT_FAILURE);}while(0)</p>
<p>#endif</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关于 </span><br><span class="line">######signal(SIGPIPE, SIG_IGN)   https://blog.csdn.net/lizhi200404520/article/details/6535983</span><br><span class="line">######socket编程(一)使用SOCK_STREAM建立可靠通信</span><br><span class="line">https://blog.csdn.net/beautyleaf/article/details/51171103</span><br><span class="line">#####setsockopt https://blog.csdn.net/yangzhongxuan/article/details/8079705</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**/***********</span><br><span class="line">server.c</span><br><span class="line">***********/**</span><br></pre></td></tr></table></figure>
<p>#include “net.h”</p>
<p>#define MAX_EVENTS 10000</p>
<p>int setblock(int sock)<br>{<br>    int ret =  fcntl(sock, F_SETFL, 0);<br>    if (ret &lt; 0 )<br>        hand_error(“setblock”);<br>    return 0;<br>}<br>int setnoblock(int sock)  //设置非阻塞模式<br>{<br>    int ret = fcntl(sock,  F_SETFL, O_NONBLOCK );<br>    if(ret &lt; 0)<br>        hand_error(“setnoblock”);<br>    return 0;<br>}</p>
<p>int main()<br>{<br>    signal(SIGPIPE,SIG_IGN);<br>  int listenfd;<br>    listenfd = socket( AF_INET, SOCK_STREAM,0 );  //create a socket stream<br>    if( listenfd &lt; 0 )<br>        hand_error( “socket_create”);<br>    setnoblock(listenfd);<br>    int on = 1;<br>    if( setsockopt( listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on))&lt; 0)<br>        hand_error(“setsockopt”);</p>
<pre><code>struct sockaddr_in my_addr;
memset(&amp;my_addr, 0, sizeof(my_addr));
my_addr.sin_family = AF_INET;
my_addr.sin_port = htons(18000);  //here is host  sequeue
my_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);

if( bind( listenfd, (struct sockaddr *)&amp;my_addr, sizeof(my_addr)) &lt; 0)
    hand_error(&quot;bind&quot;);

int lisId = listen(listenfd, SOMAXCONN);
if( lisId &lt; 0)  //LISTEN
    hand_error(&quot;listen&quot;);

struct sockaddr_in peer_addr;  //用来 save client addr
socklen_t peerlen;  
//下面是一些初始化，都是关于epoll的。
vector&lt;int&gt; clients;
int count = 0;
int cli_sock = 0;
int epfd = 0;  //epoll 的文件描述符
int ret_events;  //epoll_wait()的返回值
</code></pre><p>  struct epoll_event ev_remov, ev, events[MAX_EVENTS];  //events 用来存放从内核读取的的事件<br>    ev.events = EPOLLET | EPOLLIN;  //边缘方式触发<br>    ev.data.fd = listenfd;</p>
<pre><code>epfd = epoll_create(MAX_EVENTS);  //create epoll，返回值为epoll的文件描述符
//epfd = epoll_create(EPOLL_CLOEXEC);  //新版写法
if(epfd &lt; 0)
    hand_error(&quot;epoll_create&quot;);
int ret = epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev);  //添加时间
if(ret &lt; 0)
    hand_error(&quot;epoll_ctl&quot;);


while(1)
{
    ret_events = epoll_wait(epfd, events, MAX_EVENTS, -1);  //类似于select函数，这里是等待事件的到来。
    if(ret_events == -1)
    {
        cout&lt;&lt;&quot;ret_events = &quot;&lt;&lt;ret_events&lt;&lt;endl;
        hand_error(&quot;epoll_wait&quot;);
    }

    if( ret_events == 0)
    {
        cout&lt;&lt;&quot;ret_events = &quot;&lt;&lt;ret_events&lt;&lt;endl;
        continue;
    }
</code></pre><p>//      cout&lt;&lt;”ret_events = “&lt;&lt;ret_events&lt;&lt;endl;<br>        for( int num = 0; num &lt; ret_events; num ++)<br>        {<br>            cout&lt;&lt;”num = “&lt;&lt;num&lt;&lt;endl;<br>            cout&lt;&lt;”events[num].data.fd = “&lt;&lt;events[num].data.fd&lt;&lt;endl;<br>            if(events[num].data.fd == listenfd) //client connect<br>            {<br>                cout&lt;&lt;”listen sucess and listenfd = “&lt;&lt;listenfd&lt;&lt;endl;<br>                cli_sock = accept(listenfd, (struct sockaddr*)&amp;peer_addr, &amp;peerlen);<br>                if(cli_sock &lt; 0)<br>                    hand_error(“accept”);<br>                cout&lt;&lt;”count = “&lt;&lt;count++;<br>                printf(“ip=%s,port = %d\n”, inet_ntoa(peer_addr.sin_addr),peer_addr.sin_port);<br>                clients.push_back(cli_sock);<br>                setnoblock(cli_sock);  //设置为非阻塞模式<br>                ev.data.fd = cli_sock;// 将新连接也加入EPOLL的监听队列<br>                ev.events = EPOLLIN | EPOLLET ;<br>                if(epoll_ctl(epfd, EPOLL_CTL_ADD, cli_sock, &amp;ev)&lt; 0)<br>                    hand_error(“epoll_ctl”);<br>            }</p>
<pre><code>        else if( events[num].events &amp; EPOLLIN)
        {
            cli_sock = events[num].data.fd;
            if(cli_sock &lt; 0)
                hand_error(&quot;cli_sock&quot;);
            char recvbuf[1024];
            memset(recvbuf, 0 , sizeof(recvbuf));
            int num = read( cli_sock, recvbuf, sizeof(recvbuf));
            if(num == -1)
                hand_error(&quot;read have some problem:&quot;);
            if( num == 0 )  //stand of client have exit
            {
                cout&lt;&lt;&quot;client have exit&quot;&lt;&lt;endl;
                close(cli_sock);
                ev_remov = events[num];
                epoll_ctl(epfd, EPOLL_CTL_DEL, cli_sock, &amp;ev_remov);
                clients.erase(remove(clients.begin(), clients.end(), cli_sock),clients.end());
            }
            fputs(recvbuf,stdout);
            write(cli_sock, recvbuf, strlen(recvbuf));
        }
    }
}

return 0;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**/***********</span><br><span class="line">client.c</span><br><span class="line">***********/**</span><br></pre></td></tr></table></figure></p>
<p>#include “net.h”</p>
<p>int main()<br>{<br>    signal(SIGPIPE,SIG_IGN);<br>  int sock;<br>    sock = socket( AF_INET, SOCK_STREAM,0 );  //create a socket stream<br>    if( sock&lt; 0 )<br>        hand_error( “socket_create”);</p>
<pre><code>struct sockaddr_in my_addr;

//memset my_addr;
memset(&amp;my_addr, 0, sizeof(my_addr));
my_addr.sin_family = AF_INET;
my_addr.sin_port = htons(18000);  //here is host sequeue
</code></pre><p>//  my_addr.sin_addr.s_addr = htonl( INADDR_ANY );<br>    my_addr.sin_addr.s_addr = inet_addr(“127.0.0.1”);</p>
<pre><code>int conn = connect(sock, (struct sockaddr *)&amp;my_addr, sizeof(my_addr)) ;
if(conn != 0)
    hand_error(&quot;connect&quot;);

char recvbuf[1024] = {0};
char sendbuf[1024] = {0};
fd_set rset;
FD_ZERO(&amp;rset);   

int nready = 0;
int maxfd;
int stdinof = fileno(stdin);
if( stdinof &gt; sock)
    maxfd = stdinof;
else
    maxfd = sock;
while(1)
{
    //select返回后把原来待检测的但是仍没就绪的描述字清0了。所以每次调用select前都要重新设置一下待检测的描述字
    FD_SET(sock, &amp;rset);  
    FD_SET(stdinof, &amp;rset);
    nready = select(maxfd+1, &amp;rset, NULL, NULL, NULL); 
    cout&lt;&lt;&quot;nready = &quot;&lt;&lt;nready&lt;&lt;&quot;  &quot;&lt;&lt;&quot;maxfd = &quot;&lt;&lt;maxfd&lt;&lt;endl;
    if(nready == -1 )
        break;
    else if( nready == 0)
        continue;
    else
    {
        if( FD_ISSET(sock, &amp;rset) )  //检测sock是否已经在集合rset里面。
        {
            int ret = read( sock, recvbuf, sizeof(recvbuf));  //读数据
            if( ret == -1)
                hand_error(&quot;read&quot;);
            else if( ret == 0)
            {
                cout&lt;&lt;&quot;sever have close&quot;&lt;&lt;endl;
                close(sock);
                break;
            }
            else
            {
                fputs(recvbuf,stdout);    //输出数据
                memset(recvbuf, 0, strlen(recvbuf));
            }  
        }

        if( FD_ISSET(stdinof, &amp;rset))  //检测stdin的文件描述符是否在集合里面
        {  
            if(fgets(sendbuf, sizeof(sendbuf), stdin) != NULL)
            {
                int num = write(sock, sendbuf, strlen(sendbuf));  //写数据
                cout&lt;&lt;&quot;sent num = &quot;&lt;&lt;num&lt;&lt;endl;
                memset(sendbuf, 0, sizeof(sendbuf));
            }
        }
    }
}
return 0;
</code></pre><p>}<br><code>`</code></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/29/hello-world/" rel="next" title="Hello World">
                <i class="fa fa-chevron-left"></i> Hello World
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">jincheng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux网络编程–epoll-模型原理详解以及实例"><span class="nav-number">1.</span> <span class="nav-text">Linux网络编程–epoll 模型原理详解以及实例</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jincheng</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
