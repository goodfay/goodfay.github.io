<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>jincheng</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Linux网络编程–epoll 模型原理详解以及实例###1.简介Linux I/O多路复用技术在比较多的TCP网络服务器中有使用，即比较多的用到select函数。Linux 2.6内核中有提高网络I/O性能的新方法，即epoll 。epoll是什么？按照man手册的说法是为处理大批量句柄而作了改进的poll。要使用epoll只需要以下的三个系统函数调用： epoll_create，epoll_c">
<meta property="og:type" content="article">
<meta property="og:title" content="jincheng">
<meta property="og:url" content="http://yoursite.com/2018/06/29/Linuxepoll/index.html">
<meta property="og:site_name" content="jincheng">
<meta property="og:description" content="Linux网络编程–epoll 模型原理详解以及实例###1.简介Linux I/O多路复用技术在比较多的TCP网络服务器中有使用，即比较多的用到select函数。Linux 2.6内核中有提高网络I/O性能的新方法，即epoll 。epoll是什么？按照man手册的说法是为处理大批量句柄而作了改进的poll。要使用epoll只需要以下的三个系统函数调用： epoll_create，epoll_c">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-06-29T04:34:23.962Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jincheng">
<meta name="twitter:description" content="Linux网络编程–epoll 模型原理详解以及实例###1.简介Linux I/O多路复用技术在比较多的TCP网络服务器中有使用，即比较多的用到select函数。Linux 2.6内核中有提高网络I/O性能的新方法，即epoll 。epoll是什么？按照man手册的说法是为处理大批量句柄而作了改进的poll。要使用epoll只需要以下的三个系统函数调用： epoll_create，epoll_c">
  
    <link rel="alternate" href="/atom.xml" title="jincheng" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">jincheng</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Linuxepoll" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/29/Linuxepoll/" class="article-date">
  <time datetime="2018-06-29T04:35:58.578Z" itemprop="datePublished">2018-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Linux网络编程–epoll-模型原理详解以及实例"><a href="#Linux网络编程–epoll-模型原理详解以及实例" class="headerlink" title="Linux网络编程–epoll 模型原理详解以及实例"></a>Linux网络编程–epoll 模型原理详解以及实例</h2><p>###1.简介<br>Linux I/O多路复用技术在比较多的TCP网络服务器中有使用，即比较多的用到<code>select</code>函数。Linux 2.6内核中有提高网络I/O性能的新方法，即epoll 。<br><code>epoll</code>是什么？按照man手册的说法是为处理大批量句柄而作了改进的poll。要使用epoll只需要以下的三个系统函数调用： <code>epoll_create</code>，<code>epoll_ctl</code>，<code>epoll_wait</code>。</p>
<p>###2.select模型的缺陷</p>
<p>####(1) 在Linux内核中，select所用到的FD_SET是有限的<br>内核中有个参数<strong><code>FD_SETSIZE</code>定义了每个<code>FD_SET</code>的句柄个数：`#define </strong>FD_SETSIZE 1024`。也就是说，如果想要同时检测1025个句柄的可读状态是不可能用select实现的；或者同时检测1025个句柄的可写状态也是不可能的。 </p>
<p>####(2) 内核中实现select是使用轮询方法<br>每次检测都会遍历所有<code>FD_SET</code>中的句柄，显然select函数的执行时间与<code>FD_SET</code>中句柄的个数有一个比例关系，即select要检测的句柄数越多就会越费时</p>
<p>###3.Windows IOCP模型的缺陷<br>windows完成端口实现的AIO，实际上也只是使用内部用线程池实现的，最后的结果是IO有个线程池，你的应用程序也需要一个线程池。很多文档其实已经指出了这引发的线程context-switch所带来的代价。</p>
<p>###4.EPOLL模型的优点<br>(1) 支持一个进程打开大数目的socket描述符(FD)<br>epoll没有select模型中的限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于select 所支持的2048。下面是我的小PC机上的显示：<br><figure class="highlight plain"><figcaption><span>cat</span><a href="/proc/sys/fs/file-max">```</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">6815744 </span><br><span class="line">那么对于服务器而言,这个数目会更大。 </span><br><span class="line">(2) IO效率不随FD数目增加而线性下降 </span><br><span class="line">传统select/poll的另一个致命弱点就是当你拥有一个很大的socket集合，由于网络得延时，使得任一时间只有部分的socket是”活跃”的，而select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它只会对”活跃”的socket进行操作：这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。于是，只有”活跃”的socket才会主动去调用callback函数，其他idle状态的socket则不会。在这点上，epoll实现了一个”伪”AIO”，因为这时候推动力在os内核。在一些 benchmark中，如果所有的socket基本上都是活跃的，比如一个高速LAN环境，epoll也不比select/poll低多少效率，但若过多使用的调用epoll_ctl，效率稍微有些下降。然而一旦使用idle connections模拟WAN环境，那么epoll的效率就远在select/poll之上了。 </span><br><span class="line">(3) 使用mmap加速内核与用户空间的消息传递 </span><br><span class="line">无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就显得很重要。在这点上，epoll是通过内核于用户空间mmap同一块内存实现。</span><br><span class="line"></span><br><span class="line">###5.EPOLL模型的工作模式</span><br><span class="line">####(1) LT模式 </span><br><span class="line">`LT：level triggered`，这是缺省的工作方式，同时支持`block`和`no-block socket`，在这种模式中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。 </span><br><span class="line">####(2) ET模式 </span><br><span class="line">`ET：edge-triggered`，这是高速工作方式，只支持`no-block socket`。在这种模式下，当描述符从未就绪变为就绪时，内核就通过epoll告诉你，然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作而导致那个文件描述符不再是就绪状态(比如你在发送，接收或是接受请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误)。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核就不会发送更多的通知(only once)。不过在TCP协议中，ET模式的加速效用仍需要更多的benchmark确认。</span><br><span class="line"></span><br><span class="line">###6.EPOLL模型的使用方法</span><br><span class="line">epoll用到的所有函数都是在头文件`sys/epoll.h`中声明的，下面简要说明所用到的数据结构和函数：</span><br></pre></td></tr></table></figure></p>
<p>epoll_data、epoll_data_t、epoll_event<br>typedef union epoll_data {<br>void *ptr;<br>int fd;<br><strong>uint32_t u32; 
</strong>uint64_t u64;<br>} epoll_data_t;</p>
<p>struct epoll_event {<br>__uint32_t events; /<em> Epoll events </em>/<br>epoll_data_t data; /<em> User data variable </em>/<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">结构体epoll_event 被用于注册所感兴趣的事件和回传所发生待处理的事件。epoll_event 结构体的events字段是表示感兴趣的事件和被触发的事件，可能的取值为： </span><br><span class="line">`EPOLLIN`： 表示对应的文件描述符可以读； </span><br><span class="line">`EPOLLOUT`： 表示对应的文件描述符可以写； </span><br><span class="line">`EPOLLPRI`： 表示对应的文件描述符有紧急的数据可读； </span><br><span class="line">`EPOLLERR`： 表示对应的文件描述符发生错误； </span><br><span class="line">`EPOLLHUP`： 表示对应的文件描述符被挂断； </span><br><span class="line">`EPOLLET`： 表示对应的文件描述符有事件发生；</span><br><span class="line"></span><br><span class="line">联合体epoll_data用来保存触发事件的某个文件描述符相关的数据。例如一个client连接到服务器，服务器通过调用accept函数可以得到于这个client对应的socket文件描述符，可以把这文件描述符赋给epoll_data的fd字段，以便后面的读写操作在这个文件描述符上进行。</span><br><span class="line"></span><br><span class="line">(2)`epoll_create `</span><br><span class="line">函数声明：`intepoll_create(intsize) `</span><br><span class="line">函数说明：该函数生成一个epoll专用的文件描述符，其中的参数是指定生成描述符的最大范围。</span><br><span class="line"></span><br><span class="line">(3) `epoll_ctl`函数 </span><br><span class="line">函数声明：`intepoll_ctl(int epfd,int op, int fd, struct epoll_event *event) `</span><br><span class="line">函数说明：该函数用于控制某个文件描述符上的事件，可以注册事件、修改事件、删除事件。 </span><br><span class="line">`epfd`：由 epoll_create 生成的epoll专用的文件描述符； </span><br><span class="line">`op`：要进行的操作，可能的取值EPOLL_CTL_ADD 注册、EPOLL_CTL_MOD 修改、EPOLL_CTL_DEL 删除； </span><br><span class="line">`fd`：关联的文件描述符； </span><br><span class="line">`event`：指向epoll_event的指针； </span><br><span class="line">如果调用成功则返回0，不成功则返回-1。</span><br><span class="line"></span><br><span class="line">(4) `epoll_wait`函数 </span><br><span class="line">函数声明：`int epoll_wait(int epfd, structepoll_event * events, int maxevents, int timeout) `</span><br><span class="line">函数说明：该函数用于轮询I/O事件的发生。 </span><br><span class="line">`epfd`：由epoll_create 生成的epoll专用的文件描述符； </span><br><span class="line">`epoll_event`：用于回传代处理事件的数组； </span><br><span class="line">`maxevents`：每次能处理的事件数； </span><br><span class="line">`timeout`：等待I/O事件发生的超时值； </span><br><span class="line">返回发生事件数。</span><br><span class="line"></span><br><span class="line">###7 设计思路及模板</span><br><span class="line">首先通过`create_epoll(int maxfds)`来创建一个epoll的句柄，其中maxfds为你的epoll所支持的最大句柄数。这个函数会返回一个新的epoll句柄，之后的所有操作都将通过这个句柄来进行操作。在用完之后，记得用close()来关闭这个创建出来的epoll句柄。 </span><br><span class="line">然后在你的网络主循环里面，调用`epoll_wait(int epfd, epoll_event events, int max_events,int timeout)`来查询所有的网络接口，看哪一个可以读，哪一个可以写。基本的语法为： </span><br><span class="line">`nfds = epoll_wait(kdpfd, events, maxevents, -1); `</span><br><span class="line">其中`kdpfd`为用`epoll_create`创建之后的句柄，events是一个`epoll_event*`的指针，当`epoll_wait`函数操作成功之后，events里面将储存所有的读写事件。max_events是当前需要监听的所有socket句柄数。最后一个timeout参数指示 epoll_wait的超时条件，为0时表示马上返回；为-1时表示函数会一直等下去直到有事件返回；为任意正整数时表示等这么长的时间，如果一直没有事件，则会返回。一般情况下如果网络主循环是单线程的话，可以用-1来等待，这样可以保证一些效率，如果是和主循环在同一个线程的话，则可以用0来保证主循环的效率。epoll_wait返回之后，应该进入一个循环，以便遍历所有的事件。 </span><br><span class="line">对epoll 的操作就这么简单，总共不过4个`API：epoll_create, epoll_ctl,epoll_wait和close`。以下是man中的一个例子。</span><br></pre></td></tr></table></figure></p>
<p>struct epoll_event ev, <em>events;<br>for(;;)<br>{<br>  nfds = epoll_wait(kdpfd, events, maxevents, -1);    //等待IO事件<br>  for(n = 0; n &lt; nfds; ++n)<br>  {<br>  //如果是主socket的事件，则表示有新连接进入，需要进行新连接的处理。<br>      if(events[n].data.fd == listener)<br>      {<br>        client = accept(listener, (struct sockaddr </em>) &amp;local,  &amp;addrlen);<br>if(client &lt; 0)<br>        {<br>            perror(“accept error”);<br>            continue;<br>        }<br>        // 将新连接置于非阻塞模式<br>        setnonblocking(client);<br>        ev.events = EPOLLIN | EPOLLET;<br>        //注意这里的参数EPOLLIN | EPOLLET并没有设置对写socket的监听，<br>        //如果有写操作的话，这个时候epoll是不会返回事件的，<br>        //如果要对写操作也监听的话，应该是EPOLLIN | EPOLLOUT | EPOLLET。<br>        // 并且将新连接也加入EPOLL的监听队列<br>        ev.data.fd = client;<br>        // 设置好event之后，将这个新的event通过epoll_ctl<br>        if (epoll_ctl(kdpfd, EPOLL_CTL_ADD, client, &amp;ev) &lt; 0)<br>        {<br>            //加入到epoll的监听队列里，这里用EPOLL_CTL_ADD<br>            //来加一个新的 epoll事件。可以通过EPOLL_CTL_DEL来减少<br>            //一个epoll事件，通过EPOLL_CTL_MOD来改变一个事件的监听方式。<br>            fprintf(stderr, “epoll set insertion error: fd=%d”0, client);<br>            return -1;<br>        }<br>      }<br>      else<br>      // 如果不是主socket的事件的话，则代表这是一个用户的socket的事件，<br>      // 则用来处理这个用户的socket的事情是，比如说read(fd,xxx)之类，或者一些其他的处理。<br>        do_use_fd(events[n].data.fd);<br>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###8 EPOLL模型的简单实例</span><br></pre></td></tr></table></figure></p>
<p>#include <iostream></iostream></p>
<p>#include &lt;sys/socket.h&gt; </p>
<p>#include &lt;sys/epoll.h&gt;</p>
<p>#include &lt;netinet/in.h&gt; </p>
<p>#include &lt;arpa/inet.h&gt;</p>
<p>#include &lt;fcntl.h&gt; </p>
<p>#include &lt;unistd.h&gt; </p>
<p>#include &lt;stdio.h&gt;</p>
<p>#define MAXLINE 10 </p>
<p>#define OPEN_MAX 100</p>
<p>#define LISTENQ 20</p>
<p>#define SERV_PORT 5555 </p>
<p>#define INFTIM 1000</p>
<p>void setnonblocking(int sock)<br>{<br>  int opts;<br>  opts = fcntl(sock, F_GETFL);<br>  if(opts &lt; 0)<br>  {<br>      perror(“fcntl(sock, GETFL)”);<br>      exit(1);<br>  }<br>  opts = opts | O_NONBLOCK;<br>  if(fcntl(sock, F_SETFL, opts) &lt; 0)<br>  {<br>      perror(“fcntl(sock,SETFL,opts)”);<br>      exit(1);<br>  }<br>}</p>
<p>int main()<br>{<br>  int i, maxi, listenfd, connfd, sockfd, epfd, nfds;<br>  ssize_t n;<br>  char line[MAXLINE];<br>  socklen_t clilen;<br>  //声明epoll_event结构体的变量, ev用于注册事件, events数组用于回传要处理的事件<br>  struct epoll_event ev,events[20];<br>  //生成用于处理accept的epoll专用的文件描述符, 指定生成描述符的最大范围为256<br>  epfd = epoll_create(256);<br>  struct sockaddr_in clientaddr;<br>  struct sockaddr_in serveraddr;<br>  listenfd = socket(AF_INET, SOCK_STREAM, 0);</p>
<p>  setnonblocking(listenfd);      //把用于监听的socket设置为非阻塞方式<br>  ev.data.fd = listenfd;          //设置与要处理的事件相关的文件描述符<br>  ev.events = EPOLLIN | EPOLLET;  //设置要处理的事件类型<br>  epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev);    //注册epoll事件<br>  bzero(&amp;serveraddr, sizeof(serveraddr));<br>  serveraddr.sin_family = AF_INET;<br>  char <em>local_addr = “200.200.200.204”;<br>  inet_aton(local_addr, &amp;(serveraddr.sin_addr));<br>  serveraddr.sin_port = htons(SERV_PORT);  //或者htons(SERV_PORT);<br>  bind(listenfd,(sockaddr </em>)&amp;serveraddr, sizeof(serveraddr));<br>  listen(listenfd, LISTENQ);</p>
<p>  maxi = 0;<br>  for( ; ; )<br>  {<br>      nfds = epoll_wait(epfd, events, 20, 500); //等待epoll事件的发生<br>      for(i = 0; i &lt; nfds; ++i)                //处理所发生的所有事件<br>      {<br>        if(events[i].data.fd == listenfd)      //监听事件<br>        {<br>            connfd = accept(listenfd, (sockaddr <em>)&amp;clientaddr, &amp;clilen);<br>            if(connfd &lt; 0)<br>            {<br>              perror(“connfd&lt;0”);<br>              exit(1);<br>            }<br>            setnonblocking(connfd);          //把客户端的socket设置为非阻塞方式<br>            char </em>str = inet_ntoa(clientaddr.sin_addr);<br>            std::cout &lt;&lt; “connect from “ &lt;&lt; str  &lt;&lt;std::endl;<br>            ev.data.fd=connfd;                //设置用于读操作的文件描述符<br>            ev.events=EPOLLIN | EPOLLET;      //设置用于注测的读操作事件<br>            epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;ev);<br>            //注册ev事件<br>        }<br>        else if(events[i].events&amp;EPOLLIN)      //读事件<br>        {<br>            if ( (sockfd = events[i].data.fd) &lt; 0)<br>            {<br>              continue;<br>            }<br>            if ( (n = read(sockfd, line, MAXLINE)) &lt; 0) // 这里和IOCP不同<br>            {<br>              if (errno == ECONNRESET)<br>              {<br>                  close(sockfd);<br>                  events[i].data.fd = -1;<br>              }<br>              else<br>              {<br>                  std::cout&lt;&lt;”readline error”&lt;&lt;std::endl;<br>              }<br>            }<br>            else if (n == 0)<br>            {<br>              close(sockfd);<br>              events[i].data.fd = -1;<br>            }<br>            ev.data.fd=sockfd;              //设置用于写操作的文件描述符<br>            ev.events=EPOLLOUT | EPOLLET;  //设置用于注测的写操作事件<br>            //修改sockfd上要处理的事件为EPOLLOUT<br>            epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd, &amp;ev);<br>        }<br>        else if(events[i].events&amp;EPOLLOUT)//写事件<br>        {<br>            sockfd = events[i].data.fd;<br>            write(sockfd, line, n);<br>            ev.data.fd = sockfd;              //设置用于读操作的文件描述符<br>            ev.events = EPOLLIN | EPOLLET;    //设置用于注册的读操作事件<br>            //修改sockfd上要处理的事件为EPOLIN<br>            epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd, &amp;ev);<br>        }<br>      }<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###9.epoll进阶思考</span><br><span class="line"></span><br><span class="line">最近学习`EPOLL`模型，介绍中说将`EPOLL`与`Windows IOCP`模型进行比较，说其的优势在于解决了`IOCP`模型大量线程上下文切换的开销，于是可以看出，`EPOLL`模型不需要多线程，即单线程中可以处理`EPOLL`逻辑。如果引入多线程反而会引起一些问题。但是`EPOLL`模型的服务器端到底可以不可以用多线程技术，如果可以，改怎么取舍，这成了困扰我的问题。上网查了一下，有这样几种声音： </span><br><span class="line">(1) “要么事件驱动(如epoll)，要么多线程，要么多进程，把这几个综合起来使用，感觉更加麻烦。”； </span><br><span class="line">(2) “单线程使用epoll，但是不能发挥多核；多线程不用epoll。”； </span><br><span class="line">#####(3) “主通信线程使用epoll所有需要监控的FD，有事件交给多线程去处理”； </span><br><span class="line">#####(4) “既然用了epoll, 那么线程就不应该看到fd, 而只看到的是一个一个的业务请求/响应； epoll将网络数据组装成业务数据后, 转交给业务线程进行处理。这就是常说的半同步半异步”。 </span><br><span class="line">我比较赞同上述(3)、(4)中的观点 </span><br><span class="line">`EPOLLOUT`只有在缓冲区已经满了，不可以发送了，过了一会儿缓冲区中有空间了，就会触发`EPOLLOUT`，而且只触发一次。如果你编写的程序的网络IO不大，一次写入的数据不多的时候，通常都是`epoll_wait`立刻就会触发` EPOLLOUT`；如果你不调用` epoll`，直接写 `socket`，那么情况就取决于这个`socket`的缓冲区是不是足够了。如果缓冲区足够，那么写就成功。如果缓冲区不足，那么取决你的socket是不是阻塞的，要么阻塞到写完成，要么出错返回。所以EPOLLOUT事件具有较大的随机性，ET模式一般只用于`EPOLLIN`, 很少用于`EPOLLOUT`。 </span><br><span class="line">9.2. 具体做法 </span><br><span class="line">(1) 主通信线程使用epoll所有需要监控的FD，负责监控`listenfd`和`connfd`，这里只监听`EPOLLIN`事件，不监听`EPOLLOUT`事件； </span><br><span class="line">(2) 一旦从Client收到了数据以后，将其构造成一个消息，放入消息队列中； </span><br><span class="line">(3) 若干工作线程竞争，从消息队列中取出消息并进行处理，然后把处理结果发送给客户端。发送客户端的操作由工作线程完成。直接进行`write`。`write`到`EAGAIN`或`EWOULDBLOCK`后，线程循环`continue`等待缓冲区队列 </span><br><span class="line">发送函数代码如下：</span><br></pre></td></tr></table></figure></p>
<p>bool send_data(int connfd, char *pbuffer, unsigned int &amp;len,int flag)<br>{<br>  if ((connfd &lt; 0) || (0  == pbuffer))<br>  {<br>      return false;<br>  }</p>
<p>  int result = 0;<br>  int remain_size = (int) len;<br>  int send_size = 0;<br>  const char *p = pbuffer;</p>
<p>  time_t start_time = time(NULL);<br>  int time_out = 3;</p>
<p>  do<br>  {<br>      if (time(NULL) &gt; start + time_out)<br>      {<br>        return false;<br>      }</p>
<pre><code>send_size = send(connfd, p, remain_size, flag);
if (nSentSize &lt; 0)
{
  if ((errno == EAGAIN) || (errno == EWOULDBLOCK) || (errno == EINTR))
  {
      continue;
  }
  else
  {
      len -= remain_size;
      return false;
  }
}

p += send_size;
remain_size -= send_size;
</code></pre><p>  }while(remain_size &gt; 0);</p>
<p>  return true;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">###10 epoll 实现服务器和客户端例子</span><br><span class="line">最后我们用C++实现一个简单的客户端回射，所用到的代码文件是</span><br><span class="line"></span><br><span class="line">`net.h`  ` server.cpp `  `client.cpp`服务器端：epoll实现的，干两件事分别为：1.等待客户端的链接，2.接收来自客户端的数据并且回射；</span><br><span class="line"></span><br><span class="line">客户端：select实现，干两件事为:1.等待键盘输入，2.发送数据到服务器端并且接收服务器端回射的数据；</span><br><span class="line"></span><br><span class="line">**/***********</span><br><span class="line">net.h</span><br><span class="line">***********/**</span><br></pre></td></tr></table></figure></p>
<p>#include &lt;stdio.h&gt;</p>
<p>#ifndef _NET_H</p>
<p>#define _NET_H</p>
<p>#include <iostream></iostream></p>
<p>#include <vector></vector></p>
<p>#include <algorithm></algorithm></p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;sys/epoll.h&gt;  //epoll ways file</p>
<p>#include &lt;sys/socket.h&gt;</p>
<p>#include &lt;fcntl.h&gt;    //block and noblock</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;error.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;arpa/inet.h&gt;</p>
<p>#include &lt;netinet/in.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;signal.h&gt;</p>
<p>using namespace std;</p>
<p>#define hand_error(msg) do{perror(msg); exit(EXIT_FAILURE);}while(0)</p>
<p>#endif</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关于 </span><br><span class="line">######signal(SIGPIPE, SIG_IGN)   https://blog.csdn.net/lizhi200404520/article/details/6535983</span><br><span class="line">######socket编程(一)使用SOCK_STREAM建立可靠通信</span><br><span class="line">https://blog.csdn.net/beautyleaf/article/details/51171103</span><br><span class="line">#####setsockopt https://blog.csdn.net/yangzhongxuan/article/details/8079705</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**/***********</span><br><span class="line">server.c</span><br><span class="line">***********/**</span><br></pre></td></tr></table></figure>
<p>#include “net.h”</p>
<p>#define MAX_EVENTS 10000</p>
<p>int setblock(int sock)<br>{<br>    int ret =  fcntl(sock, F_SETFL, 0);<br>    if (ret &lt; 0 )<br>        hand_error(“setblock”);<br>    return 0;<br>}<br>int setnoblock(int sock)  //设置非阻塞模式<br>{<br>    int ret = fcntl(sock,  F_SETFL, O_NONBLOCK );<br>    if(ret &lt; 0)<br>        hand_error(“setnoblock”);<br>    return 0;<br>}</p>
<p>int main()<br>{<br>    signal(SIGPIPE,SIG_IGN);<br>  int listenfd;<br>    listenfd = socket( AF_INET, SOCK_STREAM,0 );  //create a socket stream<br>    if( listenfd &lt; 0 )<br>        hand_error( “socket_create”);<br>    setnoblock(listenfd);<br>    int on = 1;<br>    if( setsockopt( listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on))&lt; 0)<br>        hand_error(“setsockopt”);</p>
<pre><code>struct sockaddr_in my_addr;
memset(&amp;my_addr, 0, sizeof(my_addr));
my_addr.sin_family = AF_INET;
my_addr.sin_port = htons(18000);  //here is host  sequeue
my_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);

if( bind( listenfd, (struct sockaddr *)&amp;my_addr, sizeof(my_addr)) &lt; 0)
    hand_error(&quot;bind&quot;);

int lisId = listen(listenfd, SOMAXCONN);
if( lisId &lt; 0)  //LISTEN
    hand_error(&quot;listen&quot;);

struct sockaddr_in peer_addr;  //用来 save client addr
socklen_t peerlen;  
//下面是一些初始化，都是关于epoll的。
vector&lt;int&gt; clients;
int count = 0;
int cli_sock = 0;
int epfd = 0;  //epoll 的文件描述符
int ret_events;  //epoll_wait()的返回值
</code></pre><p>  struct epoll_event ev_remov, ev, events[MAX_EVENTS];  //events 用来存放从内核读取的的事件<br>    ev.events = EPOLLET | EPOLLIN;  //边缘方式触发<br>    ev.data.fd = listenfd;</p>
<pre><code>epfd = epoll_create(MAX_EVENTS);  //create epoll，返回值为epoll的文件描述符
//epfd = epoll_create(EPOLL_CLOEXEC);  //新版写法
if(epfd &lt; 0)
    hand_error(&quot;epoll_create&quot;);
int ret = epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev);  //添加时间
if(ret &lt; 0)
    hand_error(&quot;epoll_ctl&quot;);


while(1)
{
    ret_events = epoll_wait(epfd, events, MAX_EVENTS, -1);  //类似于select函数，这里是等待事件的到来。
    if(ret_events == -1)
    {
        cout&lt;&lt;&quot;ret_events = &quot;&lt;&lt;ret_events&lt;&lt;endl;
        hand_error(&quot;epoll_wait&quot;);
    }

    if( ret_events == 0)
    {
        cout&lt;&lt;&quot;ret_events = &quot;&lt;&lt;ret_events&lt;&lt;endl;
        continue;
    }
</code></pre><p>//      cout&lt;&lt;”ret_events = “&lt;&lt;ret_events&lt;&lt;endl;<br>        for( int num = 0; num &lt; ret_events; num ++)<br>        {<br>            cout&lt;&lt;”num = “&lt;&lt;num&lt;&lt;endl;<br>            cout&lt;&lt;”events[num].data.fd = “&lt;&lt;events[num].data.fd&lt;&lt;endl;<br>            if(events[num].data.fd == listenfd) //client connect<br>            {<br>                cout&lt;&lt;”listen sucess and listenfd = “&lt;&lt;listenfd&lt;&lt;endl;<br>                cli_sock = accept(listenfd, (struct sockaddr*)&amp;peer_addr, &amp;peerlen);<br>                if(cli_sock &lt; 0)<br>                    hand_error(“accept”);<br>                cout&lt;&lt;”count = “&lt;&lt;count++;<br>                printf(“ip=%s,port = %d\n”, inet_ntoa(peer_addr.sin_addr),peer_addr.sin_port);<br>                clients.push_back(cli_sock);<br>                setnoblock(cli_sock);  //设置为非阻塞模式<br>                ev.data.fd = cli_sock;// 将新连接也加入EPOLL的监听队列<br>                ev.events = EPOLLIN | EPOLLET ;<br>                if(epoll_ctl(epfd, EPOLL_CTL_ADD, cli_sock, &amp;ev)&lt; 0)<br>                    hand_error(“epoll_ctl”);<br>            }</p>
<pre><code>        else if( events[num].events &amp; EPOLLIN)
        {
            cli_sock = events[num].data.fd;
            if(cli_sock &lt; 0)
                hand_error(&quot;cli_sock&quot;);
            char recvbuf[1024];
            memset(recvbuf, 0 , sizeof(recvbuf));
            int num = read( cli_sock, recvbuf, sizeof(recvbuf));
            if(num == -1)
                hand_error(&quot;read have some problem:&quot;);
            if( num == 0 )  //stand of client have exit
            {
                cout&lt;&lt;&quot;client have exit&quot;&lt;&lt;endl;
                close(cli_sock);
                ev_remov = events[num];
                epoll_ctl(epfd, EPOLL_CTL_DEL, cli_sock, &amp;ev_remov);
                clients.erase(remove(clients.begin(), clients.end(), cli_sock),clients.end());
            }
            fputs(recvbuf,stdout);
            write(cli_sock, recvbuf, strlen(recvbuf));
        }
    }
}

return 0;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**/***********</span><br><span class="line">client.c</span><br><span class="line">***********/**</span><br></pre></td></tr></table></figure></p>
<p>#include “net.h”</p>
<p>int main()<br>{<br>    signal(SIGPIPE,SIG_IGN);<br>  int sock;<br>    sock = socket( AF_INET, SOCK_STREAM,0 );  //create a socket stream<br>    if( sock&lt; 0 )<br>        hand_error( “socket_create”);</p>
<pre><code>struct sockaddr_in my_addr;

//memset my_addr;
memset(&amp;my_addr, 0, sizeof(my_addr));
my_addr.sin_family = AF_INET;
my_addr.sin_port = htons(18000);  //here is host sequeue
</code></pre><p>//  my_addr.sin_addr.s_addr = htonl( INADDR_ANY );<br>    my_addr.sin_addr.s_addr = inet_addr(“127.0.0.1”);</p>
<pre><code>int conn = connect(sock, (struct sockaddr *)&amp;my_addr, sizeof(my_addr)) ;
if(conn != 0)
    hand_error(&quot;connect&quot;);

char recvbuf[1024] = {0};
char sendbuf[1024] = {0};
fd_set rset;
FD_ZERO(&amp;rset);   

int nready = 0;
int maxfd;
int stdinof = fileno(stdin);
if( stdinof &gt; sock)
    maxfd = stdinof;
else
    maxfd = sock;
while(1)
{
    //select返回后把原来待检测的但是仍没就绪的描述字清0了。所以每次调用select前都要重新设置一下待检测的描述字
    FD_SET(sock, &amp;rset);  
    FD_SET(stdinof, &amp;rset);
    nready = select(maxfd+1, &amp;rset, NULL, NULL, NULL); 
    cout&lt;&lt;&quot;nready = &quot;&lt;&lt;nready&lt;&lt;&quot;  &quot;&lt;&lt;&quot;maxfd = &quot;&lt;&lt;maxfd&lt;&lt;endl;
    if(nready == -1 )
        break;
    else if( nready == 0)
        continue;
    else
    {
        if( FD_ISSET(sock, &amp;rset) )  //检测sock是否已经在集合rset里面。
        {
            int ret = read( sock, recvbuf, sizeof(recvbuf));  //读数据
            if( ret == -1)
                hand_error(&quot;read&quot;);
            else if( ret == 0)
            {
                cout&lt;&lt;&quot;sever have close&quot;&lt;&lt;endl;
                close(sock);
                break;
            }
            else
            {
                fputs(recvbuf,stdout);    //输出数据
                memset(recvbuf, 0, strlen(recvbuf));
            }  
        }

        if( FD_ISSET(stdinof, &amp;rset))  //检测stdin的文件描述符是否在集合里面
        {  
            if(fgets(sendbuf, sizeof(sendbuf), stdin) != NULL)
            {
                int num = write(sock, sendbuf, strlen(sendbuf));  //写数据
                cout&lt;&lt;&quot;sent num = &quot;&lt;&lt;num&lt;&lt;endl;
                memset(sendbuf, 0, sizeof(sendbuf));
            }
        }
    }
}
return 0;
</code></pre><p>}<br><code>`</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/29/Linuxepoll/" data-id="cjizhub2n0003kct1bdv54jy0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/06/29/linux-epoll/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">linux epoll</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/06/29/Linuxepoll/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/06/29/linux-epoll/">linux epoll</a>
          </li>
        
          <li>
            <a href="/2018/06/29/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>